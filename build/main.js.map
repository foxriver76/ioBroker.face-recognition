{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport * as faceapi from 'face-api.js';\nimport { Canvas, loadImage, Image } from 'canvas';\nimport fetch from 'node-fetch';\nimport * as fs from 'fs';\n\nfaceapi.env // @ts-expect-error as docs\n    .monkeyPatch({ Canvas, Image, fetch });\n\nclass FaceRecognition extends utils.Adapter {\n    private analyzeTimer?: NodeJS.Timer | null;\n    private model?: faceapi.FaceMatcher;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'face-recognition'\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        this.on('stateChange', this.analyzeImage.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        if (!this.config.url) {\n            this.log.warn('Please configure url in adapter configuration first');\n            return;\n        }\n\n        if (this.config.reloadTrainingData) {\n            await this.uploadTrainingData();\n            this.log.info('Training data successfully uploaded. Restarting adapter now');\n            await this.extendForeignObjectAsync(`system.adapter.${this.namespace}`, {\n                native: { reloadTrainingData: false }\n            });\n            return;\n        }\n\n        await this.loadWeights();\n\n        if (this.config.retrain) {\n            this.log.info('Starting to train model');\n            try {\n                this.model = await this.trainModel();\n            } catch (e: any) {\n                this.log.error(`Could not train model: ${e.message}`);\n                this.restart();\n                return;\n            }\n\n            this.log.info('Model successfully trained. Restarting adapter now');\n            await this.extendForeignObjectAsync(`system.adapter.${this.namespace}`, {\n                native: { retrain: false }\n            });\n            return;\n        } else {\n            this.log.info('Trying to load saved model');\n            try {\n                this.model = await this.loadModel();\n                this.log.info('Successfully loaded model');\n            } catch (e: any) {\n                this.log.error(`Could not load model: ${e.message}`);\n                this.restart();\n                return;\n            }\n        }\n\n        this.subscribeStates('performDetection');\n        if (this.config.interval) {\n            this.analyzeImage();\n        }\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            if (this.analyzeTimer) {\n                clearTimeout(this.analyzeTimer);\n                this.analyzeTimer = null;\n            }\n            callback();\n        } catch {\n            callback();\n        }\n    }\n\n    /**\n     * Whole process of retriving image and analyzing it\n     */\n    private async analyzeImage(): Promise<void> {\n        if (!this.model) {\n            this.log.warn('Model not ready yet');\n            return;\n        }\n\n        if (this.analyzeTimer) {\n            clearTimeout(this.analyzeTimer);\n            this.analyzeTimer = null;\n        }\n\n        this.log.info(`Trying to get image from \"${this.config.url}\"`);\n\n        // get our image where we will perform the recognition on\n        const image: any = await loadImage(this.config.url);\n\n        // detect all faces inside the image\n        const detectedFaces = await faceapi.detectAllFaces(image).withFaceLandmarks().withFaceDescriptors();\n\n        if (detectedFaces.length) {\n            this.log.info(`Detected ${detectedFaces.length} face/s`);\n        }\n\n        for (const { descriptor, detection } of detectedFaces) {\n            const label = this.model.findBestMatch(descriptor).toString();\n            this.log.info(`Detected ${label} with a confidence of ${detection.score}`);\n            await this.setStateAsync('lastDetection', label, true);\n        }\n\n        if (this.config.interval) {\n            this.analyzeTimer = setTimeout(() => this.analyzeImage(), this.config.interval * 1000);\n        }\n    }\n\n    /**\n     * Trains the model on the initial data, it is a lazy model currently, so only preprocess input\n     */\n    private async trainModel(): Promise<faceapi.FaceMatcher> {\n        const labeledFaceDescriptors = await this.transformTrainingData();\n        return new faceapi.FaceMatcher(labeledFaceDescriptors);\n    }\n\n    /**\n     * Extracts faces from the training data and stores them\n     */\n    private async transformTrainingData(): Promise<faceapi.LabeledFaceDescriptors[]> {\n        const labeledFaceDescriptors: faceapi.LabeledFaceDescriptors[] = [];\n        const dirs = await this.readDirAsync(`${this.namespace}.images`, 'train');\n        for (const dir of dirs) {\n            const classFaceDescriptors: Float32Array[] = [];\n            if (!dir.isDir) {\n                continue;\n            }\n\n            this.log.info(`Learning \"${dir.file}\"`);\n\n            const imageNames = await this.readDirAsync(`${this.namespace}.images`, `train/${dir.file}`);\n\n            for (const image of imageNames) {\n                if (image.isDir) {\n                    continue;\n                }\n\n                const rawPath = `train/${dir.file}/${image.file}`;\n                const preprocessedPath = `train-preprocessed/${dir.file}/${image.file}`;\n                try {\n                    await this.resizeAndSaveFace(rawPath, preprocessedPath);\n                    const faceDescriptor = await this.computeFaceDescriptorFromFile(preprocessedPath);\n\n                    if (faceDescriptor) {\n                        classFaceDescriptors.push(faceDescriptor);\n                    }\n                } catch (e: any) {\n                    this.log.warn(e.message);\n                }\n            }\n\n            if (classFaceDescriptors.length) {\n                const classDescriptor = new faceapi.LabeledFaceDescriptors(dir.file, classFaceDescriptors);\n                await this.saveModel(classDescriptor);\n                labeledFaceDescriptors.push(classDescriptor);\n            } else {\n                this.log.warn(`No faces found for \"${dir.file}\"`);\n            }\n        }\n\n        return labeledFaceDescriptors;\n    }\n\n    /**\n     * Reads image from path and does preprocessing\n     *\n     * @param sourcePath path to read image from in ioBroker storage\n     */\n    private async computeFaceDescriptorFromFile(sourcePath: string): Promise<Float32Array | null> {\n        const iobFile = await this.readFileAsync(`${this.namespace}.images`, sourcePath);\n        // parse to any, because face api types seems to be made for FE\n        // @ts-expect-error types are wrong\n        const image: any = await loadImage(iobFile.file);\n        const faceDescriptor = await faceapi.computeFaceDescriptor(image);\n\n        if (Array.isArray(faceDescriptor)) {\n            this.log.warn(`Multiple targets at \"${sourcePath}\", skipping image`);\n            return null;\n        } else {\n            return faceDescriptor;\n        }\n    }\n\n    /**\n     * Extracts the face and saves it in the preprocessed folder\n     *\n     * @param rawPath path to read image from in ioBroker storage\n     * @param preprocessedPath path to write preprocessed image to in iobroker storage\n     */\n    private async resizeAndSaveFace(rawPath: string, preprocessedPath: string): Promise<void> {\n        const file = await this.readFileAsync(`${this.namespace}.images`, rawPath);\n        // @ts-expect-error wrong types\n        const image: any = await loadImage(file.file);\n\n        const detections = await faceapi.detectAllFaces(image);\n\n        if (detections.length > 1) {\n            throw new Error(`Cannot train image \"${rawPath}\", because more than one face detected`);\n        } else if (detections.length === 0) {\n            throw new Error(`Cannot train image \"${rawPath}\", because no face detected`);\n        }\n\n        const face: any = (await faceapi.extractFaces(image, detections))[0];\n\n        // write the preprocessed version to iobroker storage\n        await this.writeFileAsync(`${this.namespace}.images`, preprocessedPath, face.toBuffer('image/png'));\n    }\n\n    /**\n     * Loads the training data brought with adapter to the iobroker storage\n     */\n    private async uploadTrainingData(): Promise<void> {\n        const dirs = await fs.promises.readdir(`${__dirname}/../images`, { withFileTypes: true });\n        for (const dir of dirs) {\n            if (!dir.isDirectory()) {\n                continue;\n            }\n\n            this.log.info(`Uploading images for \"${dir.name}\"`);\n\n            const imageNames = await fs.promises.readdir(`${__dirname}/../images/${dir.name}`, {\n                withFileTypes: true\n            });\n\n            for (const image of imageNames) {\n                if (image.isDirectory()) {\n                    continue;\n                }\n\n                const sourcePath = `${__dirname}/../images/${dir.name}/${image.name}`;\n                const targetPath = `train/${dir.name}/${image.name}`;\n\n                try {\n                    const image = await fs.promises.readFile(sourcePath);\n                    await this.writeFileAsync(`${this.namespace}.images`, targetPath, image);\n                } catch (e: any) {\n                    this.log.warn(`Could not upload file \"${image.name}\": ${e.message}`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Saves given labeled descriptors\n     * @param labeledDescriptors - labeled face descriptors for a label\n     */\n    private async saveModel(labeledDescriptors: faceapi.LabeledFaceDescriptors): Promise<void> {\n        await this.writeFileAsync(\n            `${this.namespace}.models`,\n            labeledDescriptors.label,\n            JSON.stringify(labeledDescriptors.toJSON())\n        );\n    }\n\n    /**\n     * Tries to load saved model from ioBroker storage\n     */\n    private async loadModel(): Promise<faceapi.FaceMatcher> {\n        const labeledFaceDescriptors: faceapi.LabeledFaceDescriptors[] = [];\n\n        const dir = await this.readDirAsync(`${this.namespace}.models`, '');\n        for (const entry of dir) {\n            if (entry.isDir) {\n                continue;\n            }\n\n            const descriptorFile = await this.readFileAsync(`${this.namespace}.models`, entry.file);\n            // @ts-expect-error types are wrong\n            const descriptor = faceapi.LabeledFaceDescriptors.fromJSON(JSON.parse(descriptorFile.file));\n            this.log.info(`Loaded model for \"${descriptor.label}\"`);\n            labeledFaceDescriptors.push(descriptor);\n        }\n\n        return new faceapi.FaceMatcher(labeledFaceDescriptors);\n    }\n\n    /**\n     * Loads weights for the models\n     */\n    private async loadWeights(): Promise<void> {\n        await faceapi.nets.ssdMobilenetv1.loadFromDisk(`${__dirname}/../weights`);\n        await faceapi.nets.faceLandmark68Net.loadFromDisk('weights');\n        await faceapi.nets.faceRecognitionNet.loadFromDisk('weights');\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new FaceRecognition(options);\n} else {\n    // otherwise start the instance directly\n    (() => new FaceRecognition())();\n}\n"],
  "mappings": "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",
  "names": []
}
