{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.1.1\n */\n\nimport * as utils from '@iobroker/adapter-core';\nimport * as faceapi from 'face-api.js';\nimport { Canvas, loadImage, Image } from 'canvas';\nimport { dirname } from 'path';\nimport fetch from 'node-fetch';\nimport * as fs from 'fs';\n\nfaceapi.env // @ts-expect-error as docs\n    .monkeyPatch({ Canvas, Image, fetch });\n\nclass FaceRecognition extends utils.Adapter {\n    private analyzeTimer?: NodeJS.Timer | null;\n    private model?: faceapi.FaceMatcher;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'face-recognition'\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        this.log.info(`Ready to get image data from ${this.config.url}`);\n        // TODO: test dev server\n        this.config.url =\n            'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/examples/images/bbt5.jpg';\n        this.config.interval = 5;\n\n        if (!this.config.url || !this.config.interval) {\n            this.log.warn('Please configure adapter first');\n            return;\n        }\n\n        await this.trainModel();\n        this.analyzeImage();\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            if (this.analyzeTimer) {\n                clearTimeout(this.analyzeTimer);\n                this.analyzeTimer = null;\n            }\n            callback();\n        } catch {\n            callback();\n        }\n    }\n\n    /**\n     * Whole process of retriving image and analyzing it\n     */\n    private async analyzeImage(): Promise<void> {\n        if (this.analyzeTimer) {\n            this.analyzeTimer = null;\n        }\n\n        this.log.info(`Trying to get image from \"${this.config.url}\"`);\n\n        // get our image where we will perform the recognition on\n        const image = await loadImage(this.config.url);\n\n        this.analyzeTimer = setTimeout(() => this.analyzeImage(), this.config.interval * 1000);\n    }\n\n    /**\n     * Trains the model on the initial data, it is a lazy model currently, so only preprocess input\n     */\n    private async trainModel(): Promise<void> {\n        await faceapi.nets.ssdMobilenetv1.loadFromDisk(`${__dirname}/../weights`);\n        await this.transformTrainingData();\n    }\n\n    /**\n     * Extracts faces from the training data and stores them\n     */\n    private async transformTrainingData(): Promise<void> {\n        // TODO: for now we load from adapter dir\n        const dirs = await fs.promises.readdir(`${__dirname}/../images/train`, { withFileTypes: true });\n        for (const dir of dirs) {\n            if (!dir.isDirectory()) {\n                continue;\n            }\n\n            this.log.info(`Learning \"${dir.name}\"`);\n\n            const imageNames = await fs.promises.readdir(`${__dirname}/../images/train/${dir.name}`, {\n                withFileTypes: true\n            });\n            for (const image of imageNames) {\n                if (image.isDirectory()) {\n                    continue;\n                }\n\n                await this.preprocessImageFromFile(\n                    `${__dirname}/../images/train/${dir.name}/${image.name}`,\n                    `${__dirname}/../images/train-preprocessed/${dir.name}/${image.name}`\n                );\n            }\n        }\n    }\n\n    /**\n     * Reads image from path and does preprocessing\n     *\n     * @param sourcePath path to read image from\n     * @param targetPath path to write preprocessed image to\n     */\n    private async preprocessImageFromFile(sourcePath: string, targetPath: string): Promise<void> {\n        // parse to any, because face api types seems to be made for FE\n        const image: any = await loadImage(sourcePath);\n\n        const faceDetection = await faceapi.detectSingleFace(\n            image,\n            new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 })\n        );\n\n        if (faceDetection) {\n            const resizedFaceDetection = faceapi.resizeResults(faceDetection, { width: 150, height: 150 });\n            const onlyFaceImage: any = (await faceapi.extractFaces(image, [resizedFaceDetection]))[0];\n\n            // ensure dir exists\n            const dirName = dirname(targetPath);\n            if (!fs.existsSync(dirName)) {\n                await fs.promises.mkdir(dirName, { recursive: true });\n            }\n\n            await fs.promises.writeFile(targetPath, onlyFaceImage.toBuffer('image/png'));\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new FaceRecognition(options);\n} else {\n    // otherwise start the instance directly\n    (() => new FaceRecognition())();\n}\n"],
  "mappings": "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",
  "names": []
}
